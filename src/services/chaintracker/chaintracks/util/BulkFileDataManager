import { ChaintracksFetchApi } from '../Api/ChaintracksFetchApi'
import { WERR_INVALID_PARAMETER } from '../../../../sdk'
import { Hash } from '@bsv/sdk'
import { asArray, asString } from '../../../../utility/utilityHelpers.noBuffer'
import { BulkHeaderFileInfo } from './BulkHeaderFile'

/**
 * 
 */
export class BulkFileDataManager {
  private bfds: Map<string, BulkFileData> = new Map()
  fetch: ChaintracksFetchApi
  maxRetained: number | undefined

  constructor(fetch: ChaintracksFetchApi, maxRetained?: number ) {
    this.maxRetained = maxRetained
    this.fetch = fetch
  }

  async getData(fileHash: string): Promise<Uint8Array | undefined>
  {
    const bfd = this.bfds.get(fileHash)
    if (!bfd)
      throw new WERR_INVALID_PARAMETER('fileHash', `known to the BulkFileDataManager. ${fileHash} is unknown.`);
    const data = await this.ensureData(bfd)
    return data
  }

  add(file: BulkHeaderFileInfo) : void {
    if (!file.fileHash)
      throw new WERR_INVALID_PARAMETER('fileHash', `defined`);
    if (!file.sourceUrl)
      throw new WERR_INVALID_PARAMETER('sourceUrl', `defined`);
    const bfd: BulkFileData = {
      data: file.data,
      mru: Date.now(),
      fileHash: file.fileHash,
      fileName: file.fileName,
      sourceUrl: file.sourceUrl
    }
    this.bfds.set(file.fileHash, bfd)
    this.ensureMaxRetained()
  }

  private async ensureData(bfd: BulkFileData): Promise<Uint8Array | undefined>
  {
    if (bfd.data) return bfd.data
    const url = this.fetch.pathJoin(bfd.sourceUrl, bfd.fileName)
    bfd.data = await this.fetch.download(url)
    if (bfd.data) {
      bfd.mru = Date.now()
      const fileHash = asString(Hash.sha256(asArray(bfd.data)), 'base64')
      if (fileHash !== bfd.fileHash)
        throw new WERR_INVALID_PARAMETER('fileHash', `does not match downloaded data for ${url}`);
      if (this.maxRetained && this.bfds.size > this.maxRetained) {
        // Remove the least recently used data
        const oldest = Array.from(this.bfds.values()).sort((a, b) => a.mru - b.mru)[0]
        this.bfds.delete(oldest.fileHash)
      }
    }
  }

  private ensureMaxRetained() : void {
    if (this.maxRetained === undefined) return
    const withData = Array.from(this.bfds.values()).filter(bfd => bfd.data)
    if (withData.length <= this.maxRetained) return
    // Release the least recently used data
    const oldest = withData.sort((a, b) => a.mru - b.mru)[0]
    oldest.data = undefined // Release the data
  }
}

interface BulkFileData {
  data: Uint8Array | undefined
  mru: number
  fileHash: string
  fileName: string
  sourceUrl: string
}
